> 并发设计模式

# Immutability模式

解决并发问题，其实最简单的办法就是让共享变量**只有读操作**，而**没有写操作**。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：**不变性（Immutability）模式**。所谓不变性，简单来讲，就是**对象一旦被创建之后，状态就不再发生变化**。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。

实现一个具备不可变性的类，还是挺简单的。**将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了**。更严格的做法是**这个类本身也是 final 的**，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法。

Java 中非常经典的例子就是 `String`、`Integer`、`Long` 以及 `Double` 等基础类型的包装类. 它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。

但是 `String` 中有一些方法类似 `replace()` 这种操作这种操作是怎么实现的? 很简单, **对象不可变那就返回一个新的对象**. 那是不是有点浪费内存呢? 确实会的, 但是可以通过一种**享元模式(Flyweight Pattern)**来使这个消耗减小. Java 语言里面 `Long`、`Integer`、`Short`、`Byte` 等这些基本数据类型的包装类都用到了享元模式, **享元模式本质上其实就是一个对象池**:

![](https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-long-cache.png)

之前有提过, 基本上所有的基础类型的包装类都不适合做锁, 因为这些类基本都使用了享元模式, 看上去是私有, 但实际上可能是公共的, 以下就是错误示范:

```java
class A {
  Long al=Long.valueOf(1);
  public void setAX(){
    synchronized (al) {
      //省略代码无数
    }
  }
}
class B {
  Long bl=Long.valueOf(1);
  public void setBY(){
    synchronized (bl) {
      //省略代码无数
    }
  }
}
```

在使用 `Immutability` 模式的时候，需要注意以下两点：

* 对象的所有属性都是 final 的，并不能保证不可变性(对象属性也可能是一个对象)；
* 不可变对象也需要正确发布。

# Copy-on-Write模式

